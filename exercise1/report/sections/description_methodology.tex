\section{Description and Methodology}
\label{section:description_and_methodology}
To solve this task, we started out with a very simple solution, and then incrementally improving the energy consumtpion of the system. For these steps we used a basic procedure for controlling the lights; we copied the input registers into the output ones, making each button correspond to each LED output. This approach was chosen because it is easy to test the energy consumption. After some relevant testing and discussion of this solution, we implemented a somewhat more advanced LED and button behaviour, to practise our ARM assembly skills and see if the added behaviour required us to change operational mode. 

	\paragraph{Tools and utilities}
	We used the GNU toolchain for this project, e.g. \emph{arm-none-eabi-as} assembler and the \emph{arm-none-eabi-ld} linker. In addition to this, the \emph{arm-none-eabi-objcopy} was used on the binary to remove metadata. This process was automated through the exercise supplied Makefile available through itslearning. To debug the code, we used \emph{arm-none-eabi-gdb} together with Emacs. To flash the binaries to the development board we used \emph{energyAware Commander} and to test the power consumption we used the \emph{energyAware Profiler}, both provided by \emph{Silicon Labs}.
	\subsection{Setting up the GPIO}
	\label{subsection:gpio_setup}
	The gamepad created for this course requires some setup to be able to register input (button press) and create output (LED lights). We followed the instructions available at \cite[p. 24]{compendium}:
	
	\begin{itemize}
		\item Enabled the GPIO clock in the CMU by setting the CMU\_HFPERCLKEN0\_GPIO bit on the address pointed to by the CMU\_HFPERCLKEN0 constant.
		\item Enabld HIGH drive strength to the LEDs by setting the Port Control Register to 2 \cite[p. 766]{reference_manual}. Writing to this register let us select among STANDARD, LOWEST, HIGH, LOW settings to control the intensity of the LED light.
		\item Enabled LED output on bits 8-15 by writing $0x55555555$ to the \emph{PGIO\_PA\_CTRL} register.
		\item Enabled GPIO pins 0-7 as input (buttons) by writing $0x33333333$ to the \emph{GPIO\_PC\_MODEL} register.
		\item Enabled the internal pull-up resistors by writing 256 to \emph{GPIO\_PC\_DOUT}. This is needed to be able to read 3.3 volts from the input pins while a button is released. 
	\end{itemize}

	\subsection{Polling}
	\label{subsection:polling}
	\begin{figure}[t]
		\lstinputlisting[frame=single]{code/polling_loop.s}
		\caption{Tight polling loop}
		\label{code:polling_loop}
	\end{figure}
	The first and most na√Øve way of replicating the button input to the LED output, is to let the program sit in a tight loop, better known as polling. The GPIO was set up, and the program was directed to an tight, infinite loop as shown in figure \ref{code:polling_loop}.

	\subsection{Interrupts}
	\label{subsection:interrupts}
	\begin{figure}[t]
		\lstinputlisting[frame=single]{code/interrupt_handler.s}
		\caption{Interrupt handler}
		\label{code:interrupt_handler}
	\end{figure}
	Obviously, there is no need to continiously read from and write to the GPIO registers. The Giant Gecko EFM32 have interrupt support, which makes us able to trigger a subroutine only when any button is pressed. We followed the instructions available at \cite[p. 24]{compendium}:
	\begin{itemize}
		\item Wrote 0x22222222 to \emph{GPIO\_EXTIPSELL}, which enables interrupts on pin 0-7 from PORT C (buttons) \cite[p. 770]{reference_manual}
		\item Enabled low-to-high and high-to-low transition interrupts by writing 256 to \emph{GPIO\_EXTIFALL} and \emph{GPIO\_EXTRISE}.
		\item Enabled interrupt generation by writing $0xff$ to \emph{GPIO\_IEN} and interrupt handling by writing $0x802$ ($0x802$ corresponds to bits 1 and 11 for odd and even GPIO interrupts) to \emph{ISER0}.
	\end{itemize}
	
	


In addition to this, we had to create the interrupt handler itself and make entries to this handler at the NVIC. The interrupt handler looks much alike the the tight loop described in section \ref{subsection:polling}. The only difference is that the interrupt flags are cleared and the handler jumps back to where it was after the interrupt is done. The main differences is shown in figure \ref{code:interrupt_handler}. The reset handler (main procedure) was set to a tight loop (using the "b ." instruction) after the interrupts was set up.

	\subsection{Energy modes}
	The EFM32 supports five different opreational modes, which is known as Energy Modes. They are different levels of functionality and power consumption, numbered EM0 to EM4. EM0 has everything turned on, thus higher energy consumption. The higher the level, the less functionality and power consumption you get. Please see \cite[p. 2]{energy_optimization_application_note} for more details. 

	\subsubsection{EM1}
	\label{subsubsection:em1}

	\begin{figure}[t]
		\lstinputlisting[frame=single]{code/em1.s}
		\caption{Sleep loop for Energy mode 1}
		\label{code:em1}
	\end{figure}
	The system is put to sleep (Energy mode 1) using the \emph{wfi} instruction. The system does not automatically go back to sleep after an interrupt is done, so we have to write a small loop which will continiously call the \emph{wfi} instruction. The system is now in an infinite loop, but it is not continiously running, it only does one iteration each time an interrupt handler is complete. Se figure \ref{code:em1}.

	\subsubsection{EM2}
	\label{subsubsection:em2}
	
	\begin{figure}[t]
		\lstinputlisting[frame=single]{code/wfi_scr.s}
		\caption{Going to Energy mode 2}
		\label{code:wfi_scr}
	\end{figure}

	To avoid looping, we can put the system to EM2. In addition to this, we had to make the system automatically go back to sleep after the interrupt handlers are done. We do both of these things by setting the value of the SCR to the constant $6$. \emph{wfi} is still needed to put the system to sleep, but no loop is needed. Please see figure \ref{code:wfi_scr}.

		\subsubsection{EM3}
		\label{subsubsection:em3}	
		\begin{figure}[t]
			\lstinputlisting[frame=single]{code/em3.s}
			\caption{Enbling Energy mode 3}
			\label{code:em3}
		\end{figure}

		To improve the energy efficiency of our system even more, we tried out Energy Mode 3. To do enable this operational mode, we had to turn off the low frequency oscilators. This was done by writing the constant $0$ to the CMU\_LFCLKSEL. See figure \ref{code:em3}.
	
		\subsubsection{EM4}
		\label{subsubsection:em4}
	
		\begin{figure}[t]
			\lstinputlisting[frame=single]{code/em4.s}
			\caption{Enbling Energy mode 4}
			\label{code:em4}
		\end{figure}

		Energy mode 4 is the highest level, and thus the mode with less functionality. We decided to try out whether this mode was sufficient for the LED functionality. EM4 was a little more complicated. In order to put our system in this state, we had to write a sequence of bytes to the EMU\_CTRL. Please see figure \ref{code:em4} for assembly code.

	
	\subsection{Improving functionality - Animated LED rotation}
	Since the assembly code so far was rather simple, and mostly consisted of writing predefined constants to various registers, we wanted to make a little more advanced code. We decided to animate the LEDs by doing a rotate operation at a given time interval.

	\subsubsection{SysTick handler}
	To animate the LEDs, we needed some sort of timer. This was done by ... We also had to put the system back to EM1, as the SysTick interrupts were not triggered in EM2-EM4.

	\subsubsection{Rotating}
	This was done by ....

