\section{Description and Methodology}
\label{section:description_and_methodology}
To solve this task, we started out with the easiest solution, and then incrementally improving the energy consumtpion of the system. For these steps we used a simple procedure for controlling the lights; we copied the input registers into the output ones, making each button correspond to each LED output. This approach was chosen because it is easy to test the energy consumption. At the end of the exercise, we created a somewhat more advanced solution with animations and arithmetics

	\subsection{Setting up the GPIO}
	\label{subsection:gpio_setup}
	The gamepad created for this course requires some setup to be able to register input (button press) and create output (LED lights). We followed the instructions available at \cite[p. 24]{compendium}:
H
	\begin{itemize}
		\item Enabled the GPIO clock in the CMU by setting the CMU\_HFPERCLKEN0\_GPIO bit on the address pointed to by the CMU\_HFPERCLKEN0 constant.
		\item Enabld HIGH drive strength to the LEDs by setting the Port Control Register to 2 \cite[p. 766]{reference_manual}. Writing to this register let us select among STANDARD, LOWEST, HIGH, LOW settings to control the intensity of the LED light.
		\item Enabled LED output on bits 8-15 by writing $0x55555555$ to the \emph{PGIO\_PA\_CTRL} register.
		\item Enabled GPIO pins 0-7 as input (buttons) by writing $0x33333333$ to the \emph{GPIO\_PC\_MODEL} register.
		\item Enabled the internal pull-up resistors by writing 256 to \emph{GPIO\_PC\_DOUT}. This is needed to be able to read 3.3 volts from the input pins while a button is pressed down.
	\end{itemize}

	\subsection{Polling}
	\label{subsection:polling}
	\begin{figure}[h]
		\lstinputlisting[frame=single]{code/polling_loop.s}
		\caption{Tight polling loop}
		\label{code:polling_loop}
	\end{figure}
	The first and most na√Øve way of replicating the button input to the LED output, is to let the program sit in a tight loop, better known as polling. The GPIO was set up, and the program was directed to an tight, infinite loop as shown in figure \ref{code:polling_loop}.

	\subsection{Interrupts}
	\label{subsection:interrupts}
	Obviously, there is no need to continiously read from and write to the GPIO registers. The Giant Gecko EFM32 have interrupt support, which makes us able to trigger a subroutine only when any button is pressed. We followed the instructions available at \cite[p. 24]{compendium}:
	\begin{itemize}
		\item Wrote 0x22222222 to \emph{GPIO\_EXTIPSELL}, which enables interrupts on pin 0-7 from PORT C (buttons) \cite[p. 770]{reference_manual}
		\item Enabled low-to-high and high-to-low transition interrupts by writing 256 to \emph{GPIO\_EXTIFALL} and \emph{GPIO\_EXTRISE}.
		\item Enabled interrupt generation by writing $0xff$ to \emph{GPIO\_IEN} and interrupt handling by writing $0x802$ (bits 1 and 11 for odd and even GPIO interrupts) to \emph{ISER0}.
	\end{itemize}
	
	\begin{figure}[h]
		\lstinputlisting[frame=single]{code/interrupt_handler.s}
		\caption{Interrupt handler}
		\label{code:interrupt_handler}
	\end{figure}


In addition to this, we had to create the interrupt handler itself and make entries to this handler at the NVIC. The interrupt handler looks much alike the the tight loop described in section \ref{subsection:polling}. The only difference is that the interrupt flags are cleared and the handler jumps back to where it was after the interrupt is done. The main differences is shown in figure \ref{code:interrupt_handler}. The reset handler was set to a tight loop (using the "b ." instruction) after the interrupts was set up.

	\subsection{Putting our system to sleep}
	To avoid the tight loop, we decided to put the system to sleep using the "wfi" instruction. In addition to this, we wanted to automatically put the system back to sleep when the interrupt handlers were done. This was done by setting 

	\subsection{Towards energy mode 3 and 4}
	
	\subsection{Lets play a game}

	\subsection{A little section about the Makefile}
